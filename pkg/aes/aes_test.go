package aes

import (
	"reflect"
	"slices"
	"strings"
	"testing"

	"github.com/amcraig/cryptopals-go/internal/constants"
	"github.com/amcraig/cryptopals-go/internal/math/matrix"
)

func TestReadBlockIntoState(t *testing.T) {
	input := []byte("0123456789abcdef")
	want := "048c159d26ae37bf"

	state, _ := readBlockIntoState(input)
	got := slices.Concat(state...)

	if want != string(got) {
		t.Errorf("AES state is not read in as expected: %v", string(got))
	}
}

func TestStateToWords(t *testing.T) {
	state, _ := readBlockIntoState([]byte("0123456789abcdef"))
	want := word([]byte("0123"))
	words := state.Words()
	if reflect.DeepEqual(words[0], want) == false {
		t.Errorf("first word did not match expected. Got: %s Want: %s", words[0], want)
	}
}

func TestSetStateFromWords(t *testing.T) {
	words := []word{
		{0x00, 0x01, 0x02, 0x03},
		{0x04, 0x05, 0x06, 0x07},
		{0x08, 0x09, 0x0a, 0x0b},
		{0x0c, 0x0d, 0x0e, 0x0f},
	}

	var s state
	s.SetStateFromWords(words)
}

func TestKeyExpansion(t *testing.T) {
	key128 := []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
	lastFour128 := []byte{0x13, 0x11, 0x1d, 0x7f, 0xe3, 0x94, 0x4a, 0x17, 0xf3, 0x07, 0xa7, 0x8b, 0x4d, 0x2b, 0x30, 0xc5}
	keySchedule128, _, err := keyExpansion(key128)
	if err != nil {
		t.Errorf("key expansion failed: %v", err)
	}
	if len(keySchedule128) != 44 {
		t.Errorf("key schedule is not right length for a 128 bit key")
	}
	if reflect.DeepEqual([]byte(slices.Concat(keySchedule128[:4]...)), key128) == false {
		t.Errorf("first four words do not match initial 128 bit key")
	}
	if reflect.DeepEqual([]byte(slices.Concat(keySchedule128[len(keySchedule128)-4:]...)), lastFour128) == false {
		t.Errorf("last four words do not match expected")
	}

	key192 := []byte{0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5, 0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b}
	lastFour192 := []byte{0xe9, 0x8b, 0xa0, 0x6f, 0x44, 0x8c, 0x77, 0x3c, 0x8e, 0xcc, 0x72, 0x04, 0x01, 0x00, 0x22, 0x02}
	keySchedule192, _, err := keyExpansion(key192)
	if err != nil {
		t.Errorf("key expansion failed: %v", err)
	}
	if len(keySchedule192) != 52 {
		t.Errorf("key schedule is not right length for a 192 bit key")
	}
	if reflect.DeepEqual([]byte(slices.Concat(keySchedule192[:6]...)), key192) == false {
		t.Errorf("first six words do not match initial 192 bit key")
	}
	if reflect.DeepEqual([]byte(slices.Concat(keySchedule192[len(keySchedule192)-4:]...)), lastFour192) == false {
		t.Errorf("last four words do not match expected.")
	}

	key256 := []byte{0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81, 0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4}
	lastFour256 := []byte{0xfe, 0x48, 0x90, 0xd1, 0xe6, 0x18, 0x8d, 0x0b, 0x04, 0x6d, 0xf3, 0x44, 0x70, 0x6c, 0x63, 0x1e}
	keySchedule256, _, err := keyExpansion(key256)
	if err != nil {
		t.Errorf("key expansion failed: %v", err)
	}
	if len(keySchedule256) != 60 {
		t.Errorf("key schedule is not right length for a 256 bit key")
	}
	if reflect.DeepEqual([]byte(slices.Concat(keySchedule256[:8]...)), key256) == false {
		t.Errorf("first eight words do not match initial 256 bit key")
	}
	if reflect.DeepEqual([]byte(slices.Concat(keySchedule256[len(keySchedule256)-4:]...)), lastFour256) == false {
		t.Errorf("last four words do not match expected.")
	}
}

func TestWordXORWord(t *testing.T) {
	a1 := word{1, 0, 1, 0}
	b1 := word{0, 1, 1, 0}
	want1 := word{1, 1, 0, 0}
	got1 := XORWord(a1, b1)
	if reflect.DeepEqual(got1, want1) == false {
		t.Errorf("XOR of %v and %v is not equal to %v: %v", a1, b1, want1, got1)
	}
	a2 := word{1, 0, 1, 0}
	b2 := word{0, 1, 1, 0}
	want2 := word{1, 1, 0, 0}
	got2 := XORWord(a2, b2)
	if reflect.DeepEqual(got2, want2) == false {
		t.Errorf("XOR of %v and %v is not equal to %v: %v", a2, b2, want2, got2)
	}
}

func TestWordSubWord(t *testing.T) {
	w := word{0x00, 0x11, 0x22, 0x33}
	want := word{0x63, 0x82, 0x93, 0xC3}
	got := SubWord(w)
	if reflect.DeepEqual(got, want) == false {
		t.Errorf("SubWord of %v is not equal to %v", w, want)
	}
}

func TestWordRot(t *testing.T) {
	w := word{0x00, 0x11, 0x22, 0x33}
	want := word{0x11, 0x22, 0x33, 0x00}
	got := RotWord(w, 1)
	if reflect.DeepEqual(got, want) == false {
		t.Errorf("rotation result is not expected, got: %v wanted: %v", got, want)
	}
	RotWord(w, 1)
	RotWord(w, 1) // checking methods do not mutate owner
	if reflect.DeepEqual(got, want) == false {
		t.Errorf("rotation result is not expected, got: %v wanted: %v", got, want)
	}
}

func TestMethodChaining(t *testing.T) {
	w := word{0x00, 0x11, 0x22, 0x33}
	want := SubWord(word{0x11, 0x22, 0x33, 0x00})
	got := SubWord(RotWord(w, 1))
	if reflect.DeepEqual(got, want) == false {
		t.Errorf("method chaining did not work as expected, got: %v, wanted: %v", got, want)
	}

	want2 := XORWord(SubWord(word{0x11, 0x22, 0x33, 0x00}), word{0x01, 0x00, 0x00, 0x00})
	got = XORWord(got, word{constants.RoundConstant[1], 0x00, 0x00, 0x00})
	if reflect.DeepEqual(got, want2) == false {
		t.Errorf("method chaining did not work as expected, got: %v, wanted: %v", got, want)
	}
}

func TestMixColumns(t *testing.T) {
	s := state{
		{0xd4, 0x01, 0xd4, 0xf2},
		{0xbf, 0x01, 0xd4, 0x0a},
		{0x5d, 0x01, 0xd4, 0x22},
		{0x30, 0x01, 0xd5, 0x5c},
	}

	want := state{
		{0x04, 0x01, 0xd5, 0x9f},
		{0x66, 0x01, 0xd5, 0xdc},
		{0x81, 0x01, 0xd7, 0x58},
		{0xe5, 0x01, 0xd6, 0x9d},
	}
	got := s.MixColumns()

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("generated state mix was not expected, got: %v wanted: %v", got, want)
	}
}

func TestInvMixColumns(t *testing.T) {
	s := state{
		{0x04, 0x01, 0xd5, 0x9f},
		{0x66, 0x01, 0xd5, 0xdc},
		{0x81, 0x01, 0xd7, 0x58},
		{0xe5, 0x01, 0xd6, 0x9d},
	}

	want := state{
		{0xd4, 0x01, 0xd4, 0xf2},
		{0xbf, 0x01, 0xd4, 0x0a},
		{0x5d, 0x01, 0xd4, 0x22},
		{0x30, 0x01, 0xd5, 0x5c},
	}
	got := s.InvMixColumns()

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("generated state mix was not expected, got: %v wanted: %v", got, want)
	}
}

func TestAddRoundKey(t *testing.T) {
	s, _ := readBlockIntoState(
		[]byte{
			0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d,
			0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34,
		})

	key := []byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}
	ks, _, _ := keyExpansion(key)

	want := state{
		{0x19, 0xa0, 0x9a, 0xe9},
		{0x3d, 0xf4, 0xc6, 0xf8},
		{0xe3, 0xe2, 0x8d, 0x48},
		{0xbe, 0x2b, 0x2a, 0x08},
	}

	got := s.AddRoundKey(matrix.Transpose(ks[0:4]))

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("round key added to state was not expected, \ngot: %#v \n\nwanted: %#v", got, want)
	}

}

func Test128Cipher(t *testing.T) {
	in := []byte{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34}
	key := []byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}
	want := []byte{0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32}

	got, _ := Cipher(in, key)

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("cipher output is unexpected. Got: %#v Wanted:%#v", got, want)
	}
}

func Test128InvCipher(t *testing.T) {
	ct := []byte{0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32}
	key := []byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}
	want := []byte{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34}

	got, _ := InvCipher(ct, key)

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("cipher output is unexpected. Got: %#v Wanted:%#v", got, want)
	}
}

func Test192Cipher(t *testing.T) {
	in := []byte{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A}
	key := []byte{0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B}
	want := []byte{0xBD, 0x33, 0x4F, 0x1D, 0x6E, 0x45, 0xF2, 0x5F, 0xF7, 0x12, 0xA2, 0x14, 0x57, 0x1F, 0xA5, 0xCC}

	got, _ := Cipher(in, key)

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("cipher output is unexpected. Got: %#v Wanted:%#v", got, want)
	}
}

func Test192InvCipher(t *testing.T) {
	ct := []byte{0xBD, 0x33, 0x4F, 0x1D, 0x6E, 0x45, 0xF2, 0x5F, 0xF7, 0x12, 0xA2, 0x14, 0x57, 0x1F, 0xA5, 0xCC}
	key := []byte{0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52, 0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5, 0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B}
	want := []byte{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A}

	got, _ := InvCipher(ct, key)

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("cipher output is unexpected. Got: %#v Wanted:%#v", got, want)
	}
}

func Test256Cipher(t *testing.T) {
	in := []byte{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A}
	key := []byte{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4}
	want := []byte{0xF3, 0xEE, 0xD1, 0xBD, 0xB5, 0xD2, 0xA0, 0x3C, 0x06, 0x4B, 0x5A, 0x7E, 0x3D, 0xB1, 0x81, 0xF8}

	got, _ := Cipher(in, key)

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("cipher output is unexpected. Got: %#v Wanted:%#v", got, want)
	}
}

func Test256InvCipher(t *testing.T) {
	ct := []byte{0xF3, 0xEE, 0xD1, 0xBD, 0xB5, 0xD2, 0xA0, 0x3C, 0x06, 0x4B, 0x5A, 0x7E, 0x3D, 0xB1, 0x81, 0xF8}
	key := []byte{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4}
	want := []byte{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A}

	got, _ := InvCipher(ct, key)

	if reflect.DeepEqual(got, want) == false {
		t.Errorf("cipher output is unexpected. Got: %#v Wanted:%#v", got, want)
	}
}

func TestInvalidCipherKey(t *testing.T) {
	in := []byte{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A}
	key := []byte{0x00, 0x01, 0x02, 0x03}

	// https://stackoverflow.com/a/62028796
	// This recovers from the panic thrown by Cipher and continues
	defer func() { _ = recover() }()

	// Cipher should throw a panic
	Cipher(in, key)

	// This should pass if Cipher throws a panic and fails if it succeeds.
	// Never reaches here if `OtherFunctionThatPanics` panics.
	t.Errorf("did not panic")
}

func TestGenerateAESKey(t *testing.T) {
	_, err := GenerateAESKey(10)
	if err == nil {
		t.Errorf("AES key generated should have failed")
	}

	for _, i := range []int{16, 24, 32} {
		key, _ := GenerateAESKey(i)
		if len(key) != i {
			t.Errorf("key length does not match specified: %d, got : %#v", i, key)
		}
	}
}

func TestAESCBC(t *testing.T) {
	key := []byte("YELLOW SUBMARINE")
	iv := []byte(strings.Repeat("\x00", AESBlockSize))

	plaintext := []byte("YELLOW SUBMARINE NOT A CATAMARAN")

	ct, _ := EncryptAESCBC(plaintext, key, iv)
	pt, _ := DecryptAESCBC(ct, key, iv)

	if reflect.DeepEqual(pt, plaintext) == false {
		t.Errorf("the regenerated plaintext does not match the original, want: %v, got %v", plaintext, pt)
	}
}
